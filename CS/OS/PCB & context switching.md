# PCB(Process Control Block)

- 프로세스와 관련된 정보(메타 데이터)를 저장하는 자료 구조
- 해당 `프로세스를 식별`하기 위해 꼭 필요한 정보들이 저장됨
- PCB는 언제 사용하나요?
    - 모든 프로세스는 실행하기 위해 CPU가 필요하지만, CPU는 한정적임.
    - 프로세스들이 차례대로 돌아가며 한정된 시간 동안만 CPU를 사용할 수 있음
    - 운영체제는 `프로세스의 실행 순서를 관리`하고, 프로세스에 CPU를 비롯한 `자원을 배분`함.
    
        **➡️ 수많은 프로세스 사이에서 PCB로 특정 프로세스를 식별, 해당 프로세스를 처리**
    
- PCB는 **프로세스 생성 시에 만들어지고 실행이 끝나면 폐기**됨
    - 새로운 프로세스가 생성되었다 == 운영체제가 PCB를 생성했다
    - 프로세스가 종료되었다 == 운영체제가 해당 PCB를 폐기했다
    
        ![image](https://github.com/LeeDahee23/Study/assets/82389864/153cd551-c597-4c4b-8e28-8897446c8877)
  

### PCB가 필요한 이유

프로세스는 CPU 자원을 차례대로 돌아가며 이용한다. 만약 인터럽트가 발생해서, **현재 프로세스가 잠시 대기** 상태가 되고 **인터럽트가 발생된 프로세스를 실행 상태**로 바꿔야 할 때, **대기 중인 프로세스의 정보를 잃어버리면 프로그램을 처음부터 다시 시작**해야 한다.

그래서 대기하다가 다시 실행할 때, **대기 상태 직전의 실행 정보를 저장**해두면 다시 실행 상태가 되었을 때 그대로 **프로세스가 이어서 진행**될 수 있을 것이다.

### PCB에 담기는 정보

![image](https://github.com/LeeDahee23/Study/assets/82389864/a4cd5758-42ae-46ce-951c-64be4b46734f)
  
1. Process ID (PID)
    - 특정 프로세스를 식별하기 위해 부여하는 고유한 번호
    - 작업 관리자(window) or 활성 상태 보기(macOS)
        
        <img src="https://github.com/LeeDahee23/Study/assets/82389864/4cc8ecdb-60b3-4ff9-847d-a342af7144b3" width="50%" />
  
2. Registers
    - 프로세스는 이전까지 진행했던 작업들을 그대로 이어 실행하도록, 자신의 실행 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원
    - 레지스터란?
        - `프로세서 내에서` 자료를 보관하는 아주 `빠른 기억 장소`
        - 극히 소량의 데이터나 처리 중인 중간 결과와 같이 프로세서가 바로 사용할 수 있는 데이터
3. Process State
    - 현재 프로세스가 어떤 상태인지
    - 예) 입출력장치를 사용하기 위해 대기중 상태 / CPU를 사용하기 위해 대기중 상태 / CPU 이용 중인 상태
4. CPU 스케줄링 정보
    - 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보
5. Memory 관리 정보
    - 프로세스마다 메모리에 저장된 위치가 다른데, PCB에 그 주소에 대한 정보가 담겨 있음.
    - 페이지 테이블 정보와 같은 프로세스의 메모리 주소를 알 수 있는 정보가 담김.
6. 사용한 파일과 입출력장치 목록
    - 어떤 입출력장치가 해당 프로세스에 할당되었는지, 어떤 파일들을 열었는지에 대한 정보
7. Program Counter
    - 다음에 실행될 명령어의 정보를 가지고 있음.
    - 레지스터 중 하나

# Context Switching

### context

- 하나의 `프로세스 수행을 재개`하기 위해 기억해야 할 정보
- 인터럽트가 발생하면 운영체제는 해당 프로세스의 PCB에 context를 백업

- 원래 `실행중이던 프로세스의 상태를 PCB에 보관`하고, `새로 들어오는 프로세스의 PCB 정보`를 바탕으로 레지스터에 `값을 적재`하는 과정
- 언제 발생❓
    
    CPU를 사용할 수 있는 시간이 다 되었을 때, 인터럽트 발생 시 등에 발생
    

### 과정

![image](https://github.com/LeeDahee23/Study/assets/82389864/31b9cd10-e40e-4caf-8a0d-105e1e8ee053)

  
### 특징

- context switching이 자주 일어나면 프로세스는 그만큼 빨리 번갈아 가며 수행되기 때문에 프로세스들이 동시에 실행되는 것처럼 보임.
- But❗ context switching이 너무 자주 일어나면 오버헤드(추가적인 시간 & 메모리)가 발생할 수 있음
    - context switching을 하는 동안은 CPU가 아무 일도 하지 못함.
    - 오버헤드가 잦아지면 성능이 악화될 수 있음.

## 출처

[도서] 혼자 공부하는 컴퓨터 구조 + 운영체제

[https://velog.io/@haero_kim/PCB-와-Context-Switching-알아보기](https://velog.io/@haero_kim/PCB-%EC%99%80-Context-Switching-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0)
