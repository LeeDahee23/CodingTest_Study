# 메모리 할당 방식

- what? 사용자가 사용하는 프로세스가 어떻게 메모리(유저 영역)에 할당되는지
1. **연속 메모리 할당**
    - 프로세스에 `연속적인` 메모리 공간을 할당하는 방식
    1. 고정 분할 방식 : 물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누어 두고 `각 분할에 하나의 프로세스를 적재`해 실행하는 방식
        - 외부 단편화 O, 내부 단편화 O
    2. 가변 분할 방식 : 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 `동적으로 변하는` 방식
        - 외부 단편화 O, 내부 단편화 X
        - 동적 메모리 할당 문제
            
            <p align="center"><img width="600" alt="동적 메모리 할당 문제" src="https://github.com/LeeDahee23/Study/assets/82389864/4b81f8c0-f112-4dfa-97e2-a7b7a01bc3d3"></p><br/>
  
            | 이름 | 설명 |
            | ------- | --- |
            | 최초 적합 | 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식 |
            | 최적 적합 | 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식 |
            | 최악 적합 | 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식 |
    
    - ⭐️ 외부 단편화 vs 내부 단편화
        - 단편화: 기억 장치의 `빈 공간` 또는 `여러 개의 조각`으로 나뉘는 현상
        
        - **외부 단편화**
            - `프로그램의 크기보다 분할의 크기가 작은 경우`에는 **해당 분할이 비어있는데도** 불구하고 프로그램을 **적재하지 못하는** 현상
                
                <p align="center"><img width="600" alt="외부 단편화" src="https://github.com/LeeDahee23/Study/assets/82389864/e937cb56-1e13-4e95-8f5d-1b36ea769fcb"></p>
                
        
        - **내부 단편화**
            - `프로그램의 크기보다 분할의 크기가 큰 경우` 해당 분할에 **프로그램을 적재하고 남는 현상**
            하나의 분할 내부에 사용되지 않는 메모리 조각이 생기는 현상
                
                <p align="center"><img width="600" alt="내부 단편화" src="https://github.com/LeeDahee23/Study/assets/82389864/2fd1fb38-000f-44ed-abc2-e4114c2ab816"></p>
                

1. **불연속 메모리 할당**
    - 프로세스에 `불연속적인` 메모리 공간을 할당하는 방식
    - 가상 메모리 관리
        - 물리메모리보다 큰 프로세스를 실행할 수 없음
        - 가상 메모리: 실행하고자 하는 `프로그램을 일부만 메모리에 적재`하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
    1. 페이징 : 단위가 고정크기
    2. 세그먼테이션 : 단위가 가변크기
    

## 페이징

- 메모리와 프로세스를 일정한 단위로 자르고, 이를 메모리에 `불연속적`으로 할당하는 방식
- 페이지: `프로세스`의 논리 주소 공간을 일정한 크기로 자른 단위
- 프레임: `메모리` 물리 주소 공간을 `페이지와 동일한 크기`로 자른 단위
    
    - 논리 주소 ? 물리 주소 ?
        - 물리 주소: 메모리 입장에서 바라본 주소, 정보가 실제로 저장된 하드웨어상의 주소
        - 논리 주소: CPU와 실행 중인 프로그램 입장에서 바라본 주소, 실행 중인 프로그램 각각에게 부여된 0번지부터 시작하는 주소

<br/><p align="center"><img width="600" alt="페이징" src="https://github.com/LeeDahee23/Study/assets/82389864/5978394c-5771-4928-97c4-172dddc9aa75"></p><br/>

- 페이지 테이블: 페이지 번호와 프레임 번호를 짝지어 주는 표
    - 프로세스가 물리 주소에 불연속적으로 배치되더라도 논리 주소(CPU가 바라보는 주소)에는 연속적으로 배치되도록 함
    - CPU가 페이지 테이블을 통해 페이지 번호만 보고, 해당 페이지가 어느 프레임에 적재되어 있는지 알 수 있음
    - 페이지 테이블의 시작주소를 page table base register에 저장함

<br/><p align="center"><img alt="페이징2" src="https://github.com/LeeDahee23/Study/assets/82389864/b7aa4296-8832-44a0-a1bd-57fc2f543aa5"></p><br/>

- 외부 단편화 X
    - 페이지들의 크기가 프레임보다 큰 경우는 없기 때문
- 내부 단편화 O
    - 페이지 크기: 10, 프로세스의 크기: 26 → 마지막 페이지의 크기: 6
    - 마지막 페이지에는 4만큼의 크기가 남음!

## 세그먼테이션

- 프로세스를 `논리적 내용을 기반으로 나눠서` 메모리에 배치하는 방식
- 세그먼트: 코드, 데이터, 힙, 스택 영역 등과 같은 논리적 영역, 집합
    - 가변 크기
- 세그먼트 테이블: `세그먼트 번호`, `시작 주소`, `세그먼트 크기`를 가짐

<br/><p align="center"><img width="600" alt="세그먼테이션" src="https://github.com/LeeDahee23/Study/assets/82389864/022e1b53-37b4-40bd-bb87-ed7a0e0bc024"></p><br/>

- 외부 단편화 O
    - 메모리에 계속해서 세그먼트가 들어가고 나가고 반복하면, 각각의 상주되어 있는 세그먼트들 사이에는 작은 빈틈이 생길 수 있음 → 작은 빈틈보다 큰 세그먼트는 메모리에 들어갈 수 없음
- 내부 단편화 X
    - 세그먼트의 크기가 가변이기 때문

|  | 페이징 | 세그먼테이션 |
| --- | --- | --- |
| 크기 | 고정 | 가변 |
| 외부 단편화 | X | O |
| 내부 단편화 | O | X |
| 장점| 외부 단편화를 해결하기 때문에, 현재 대부분은 페이징 기법을 사용 | 보호와 공유에 효율적(세그먼트는 논리적 단위, 페이징은 고정 크기) |

## 참고

[https://ko.wikipedia.org/wiki/단편화](https://ko.wikipedia.org/wiki/%EB%8B%A8%ED%8E%B8%ED%99%94)

https://baebalja.tistory.com/416

[https://velog.io/@codemcd/운영체제OS-13.-페이징](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-13.-%ED%8E%98%EC%9D%B4%EC%A7%95)

[https://velog.io/@khs0415p/11-메모리의-주소-공간-물리주소와-논리주소](https://velog.io/@khs0415p/11-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84-%EB%AC%BC%EB%A6%AC%EC%A3%BC%EC%86%8C%EC%99%80-%EB%85%BC%EB%A6%AC%EC%A3%BC%EC%86%8C)

[보호와 공유 참고](https://dar0m.tistory.com/269)
