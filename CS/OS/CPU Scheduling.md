# CPU 스케줄링

- 운영체제가 프로세스들에게 공정하고 `합리적으로 CPU 자원을 배분`하는 것
- 컴퓨터 성능에 직결
    - 프로세스들에게 CPU를 잘 배분하지 못하면 실행되지 못하는 프로세스가 생기거나, 당장 급하지 않은 프로세스들만 실행될 수 있음

### 평가 기준

![image](https://github.com/LeeDahee23/Study/assets/82389864/e0bb5137-3706-4a30-8c90-7a3df18ab23d)
*출처 : https://deious.tistory.com/290*

<br/>

| CPU 사용률(Utilization) | 전체 시스템 시간 중에서 CPU가 작업을 처리하는 시간의 비율 |
| --- | --- |
| 처리량(Throughput) | CPU가 단위 시간당 작업을 마친 프로세스의 수, CPU 사용률이 높고 프로세스들에 적정한 시간을 공평하게 제공했다면 처리량이 높습니다. |
| 응답 시간(Response Time) | 요청 후 응답이 오기 시작할 때까지의 시간. |
| 대기 시간(Waiting Time) | 프로세스가 준비 큐에서 대기하는 시간들의 총합. |
| 반환 시간(Turnaround Time) | 프로세스 시작부터 끝날 때까지 걸리는 시간(대기 시간 + 실행 시간) |

- 목표: CPU 사용률 ↑ / 처리량 ↑ / 응답 시간 ↓ / 대기 시간 ↓ / 반환 시간 ↓

### 프로세스 우선순위

- `프로세스의 중요도, 상황에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해` 운영체제는 프로세스마다 우선순위를 부여함.
- PCB에 저장
- 우선순위가 높다 → 빨리 처리해야 한다
- 우선순위 높은 프로세스 예시 - 입출력 작업이 많은 프로세스
    
    ```
    입출력 집중 프로세스(I/O bound process) : 입출력 작업이 많은 프로세스 
    → 실행 상태보다는 입출력을 위한 대기 상태에 더 많이 머무르게 됨.
    
    CPU 집중 프로세스(CPU bound process) : CPU 작업이 많은 프로세스
    → 대기 상태보다는 실행 상태에 더 많이 머무름.
    ```
    
    - 입출력 집중 프로세스와 CPU 집중 프로세스가 동시에 CPU 자원을 요구
        - 입출력 집중 프로세스를 빨리 실행하는 게 효율적
        - why? 입출력 집중 프로세스는 대기 상태가 될 예정이기 때문에 먼저 처리하면 다른 프로세스가 CPU를 사용할 수 있기 때문

### 프로세스 상태

![image](https://github.com/LeeDahee23/Study/assets/82389864/cd03dca6-a067-44d1-b1c6-c4945b85c7e6)


### 스케줄링 큐

- PCB에 적힌 우선순위를 운영체제가 일일이 모든 프로세스의 PCB를 확인하는 것은 비효율적
- CPU / 메모리 / 입출력장치 를 사용하고 싶은 프로세스를 **줄을 세움**
- 종류
    - 준비 큐(Ready Queue) : `CPU를 이용`하고 싶은 프로세스들이 서는 줄
    - 대기 큐(Waiting Queue) : `입출력장치를 이용`하기 위해 대기 상태에 접어든 프로세스들이 서는 줄
- 우선순위가 낮은 프로세스들이 먼저 큐에 들어왔어도 우선순위가 높은 프로세스가 먼저 처리될 수 있음

### 선점형과 비선점형 스케줄링

만약 어떤 프로세스가 CPU를 잘 사용 중인데, 갑자기 급한 다른 프로세스가 CPU를 요청한다면?

1. 사용 중이던 CPU를 뺏어서 다른 프로세스에게 할당 → 선점형 스케줄링
2. 사용 중인 프로세스가 작업을 끝낼 때까지 기다리게 함 → 비선점형 스케줄링

1. 선점형 스케줄링(Preemptive scheduling)
    - 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 `강제로 빼앗아 다른 프로세스에 할당`할 수 있는 스케줄링 방식
    - 독점할 수 없음
    - 프로세스마다 정해진 시간동안 CPU를 사용하고, 타이머 인터럽트가 발생하면 운영체제가 CPU 자원을 빼앗아 다른 프로세스에 할당함.
2. 비선점형 스케줄링(non-preemptive scheduling)
    - 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 `다른 프로세스가 끼어들 수 없는` 스케줄링 방식
    - 독점할 수 있음

|  | 선점형 스케줄링 | 비선점형 스케줄링 |
| :---: | --- | --- |
| 장점 | 자원 독점을 막고 프로세스들에게 골고루 자원 배분 가능 | 문맥 교환의 횟수가 적기 때문에 오버헤드도 적음 |
| 단점 | 문맥 교환 과정에서 오버헤드 발생할 수 있음 | 어떤 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 대기 |

# CPU 스케줄링 알고리즘

### 비선점형 스케줄링

1. **FCFS(First Come First Served, 선입 선처리 스케줄링)**
    - 단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식
    - 대기 시간이 매우 길어질 수 있음
        - CPU를 오래 사용하는 프로세스가 먼저 도착하면 다른 프로세스는 끝날 때까지 대기

1. **SJF(Shortest Job First, 최단 작업 우선 스케줄링)**
    - CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 (비선점형) 스케줄링 방식

### 선점형 스케줄링

1. **RR(Round Robin, 라운드 로빈 스케줄링)**
    - FCFS + 타임 슬라이스
        - 타임 슬라이스 : 각 프로세스가 `CPU를 사용할 수 있는 정해진 시간`
    - 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 사용하는 선점형 스케줄링
    - 큐에 들어온 순서대로 CPU를 사용하되, 정해진 시간이 끝났는데 아직 프로세스가 완료되지 않았다면 다시 큐에 맨 뒤에 들어감.

1. **SRT(Shortest Remaining Time, 최소 잔여 시간 우선 스케줄링)**
    - SJF + RR
    - 정해진 타임 슬라이스만큼 CPU를 사용하되, 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스 선택

1. **Priority Scheduling(우선순위 스케줄링)**
    - 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 방식

      ```
      🤦🏻‍♀️ 기아 현상(Starvation) : 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스들에 의해 실행이 계속해서 연기 됨.
      ```
      ```
      💡 에이징(Aging) : 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식
      ```
    

1. **MLQ(MultiLevel Queue, 다단계 큐 스케줄링)**
    - 준비 큐를 우선순위 별로 여러 개 사용
    - 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고 그 다음 우선순위 큐에 있는 프로세스들을 처리하는 방식

1. **MFQ(MultiLevel Feedback Queue, 다단계 피드백 큐 스케줄링)**
    - 프로세스들이 큐 사이를 이동할 수 있는 다단계 큐 스케줄링
        - 프로세스들이 큐 사이를 이동할 수 없기 때문에 기아 현상 발생
            
            → `에이징 기법`을 적용해 기아현상 예방
            
    - 새로 준비상태가 된 프로세스를 가장 높은 우선순위 큐에 삽입되고 타임 슬라이스 동안 실행함
        
        → 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행됨
        
        ⇒ CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아짐
        
    - CPU 집중 프로세스들은 우선순위가 낮아지고, 입출력 집중 프로세스들은 우선순위가 높은 큐에서 실행이 끝남
    - 구현이 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘

## 질문

1. 프로세스 상태에서 대기에서 준비 상태로 돌아간다고 하는데, 그럼 종료는 언제 되나요?
    - 먼저 각 상태에 대해 살펴보겠습니다.
        - **`준비 상태`**: 프로세스가 **CPU에 실행되기 위해 대기**하는 상태입니다. 당장이라도 CPU를 할당받아 실행할 수 있지만, 아직 자신의 차례가 아니기에 기다리고 있는 상태입니다. 따라서 준비 큐에는 CPU에서 실행되기 위해 기다리는 프로세스들이 들어있습니다.
        - **`실행 상태`**: 프로세스가 **CPU를 할당받아 실행 중**인 상태
        - **`대기 상태`**: 프로세스가 **특정 자원(IO)이나 이벤트를 기다리는** 상태입니다. 입출력 작업은 CPU에 비해 처리 속도가 느리기 때문에, 입출력 작업을 요청한 프로세스는 입출력 장치가 입출력을 끝낼 때까지 기다려야 합니다. 쉽게 말해 **자원(입출력 장치)을 할당받기 위한 준비 상태**라고 할 수 있을 것 같습니다. 따라서 대기 큐에는 입출력 장치를 할당받기 위해 기다리는 프로세스들이 들어있습니다.
        - `**종료 상태**`: 프로세스가 **정상적으로 실행이 완료**되어 프로세스가 종료된 상태입니다. 종료 상태의 프로세스는 할당된 모든 자원들이 회수되고 PCB만 커널에 남아있게 됩니다. 운영체제가 해당 프로세스의 흔적들을 최종적으로 정리한 후 PCB를 삭제하면 프로세스는 완전히 사라지게 됩니다.
    - 참고로 `준비 상태, 실행 상태, 대기 상태`를 `**활성 상태**`라고 합니다. 생성 상태와 종료 상태는 프로세스가 생성되고 사라지는 과정에서 잠시 있게 되는 상태이기 때문에 제외합니다.
    - 각 상태에서 다른 상태로 넘어가는 과정에 대해서 소개하겠습니다.
        - 준비 → 실행 (Dispatch) : 스케줄링 알고리즘을 통해 우선순위가 높은 프로세스를 선정하여 CPU를 할당하는 과정입니다.
        - 실행 → 준비 (Time runout) : 타이머 인터럽트가 발생하여 프로세스의 제어권을 빼앗는 것입니다.
        - 실행 → 대기 (Block) : 프로세스가 자원, 이벤트 등을 기다리기 위해 대기로 전환하는 과정입니다.
        - 대기 → 준비 (Wake up) : 입출력이 완료되거나 자원이 할당되어 다시 실행하기 위해 준비 상태로 전이됩니다.
    - 대기 상태는 프로세스가 실행 단계에 있다가 중간에 IO 처리가 필요하게 되면, 실행을 중단하고 IO 장치가 IO 처리를 끝낼 때까지 대기 중인 상태입니다. IO 처리가 끝나게 되어서 이제 다시 실행을 하려고 할 때, CPU에서 실행을 할 수 있는 상태를 의미하는 준비 상태로 넘어가게 됩니다.
    - 이 세 과정을 계속해서 진행하다가 해당 프로세스가 정상적으로 실행을 완료하게 되었을 때 비로소 종료 상태로 넘어가게 되는 것입니다.
    
2. 대기 시간이 프로세스가 준비 큐에서 대기하는 시간들의 총합이라고 했는데, 생성 → 준비 일 때만 인가요, 대기 → 준비 일 때도 포함인건가요?
    - 프로세스가 **CPU를 할당 받았다가 다시 뺏기고 또 기다릴 수도 있는데** 이 `모든 시간을 더한 것`이 대기 시간이라고 합니다.
    - 예를 들어 프로세스가 실행 중이다가 타이머 인터럽트가 발생해서 `실행 → 준비` 로 되었을 때 준비 큐에서 대기 하는 시간도 대기 시간에 포함됩니다.
    혹은 입출력 처리를 위해 `실행 → 대기`로 넘어갔다가 입출력 처리를 마치고 다시 `대기 → 준비`로 넘어왔을 때 준비 큐에서 대기 하는 시간도 대기 시간에 포함됩니다.

3. 입출력 집중 프로세스와 CPU 집중 프로세스가 동시에 CPU 자원을 요구할 때 입출력 집중 프로세스가 먼저 처리가 되고 나서 대기 → 준비 상태로 다시 돌아갔을 때에는 어떤 프로세스가 먼저 실행 되나요?
    - 일단 입출력 집중 프로세스와 CPU 집중 프로세스가 동시에 CPU를 요구하면 입출력 집중 프로세스가 먼저 실행 상태로 넘어갑니다.
        - 이유
            
            입출력 집중 프로세스와 CPU 집중 프로세스는 어떤 작업을 더 많이 하냐에 따라 달라집니다. 입출력 집중 프로세스는 CPU burst보다 IO burst을 더 많이 하고, CPU 집중 프로세스는 IO burst보다 CPU burst를 더 많이 합니다. 그 말은 입출력 집중 프로세스는 CPU는 조금 사용하고 IO 장치를 기다리는 대기 상태로 금방 넘어간다는 의미입니다. 따라서 **입출력 집중 프로세스의 짧은 CPU 작업을 빨리 해치우고 넘겨버려서 다른 프로세스가 CPU를 사용할 수 있도록 하는 것이 효율적이게 되는 것**입니다.
            
            ![image](https://github.com/LeeDahee23/Study/assets/82389864/7ea66156-dd5a-4f1a-afec-cda11517473c)

            
    - 입출력 집중 프로세스가 대기 상태로 넘어가고 나서 입출력 처리가 끝나고 다시 준비 상태로 돌아가게 되면(== 준비큐에 들어감) 다시 자신의 순서가 돌아올 때까지 기다립니다. 여기에서 순서를 정하는 방식이 CPU 스케줄링입니다.

### 출처

[도서] 혼자 공부하는 컴퓨터구조 + 운영체제 (강민철, 한빛미디어)

https://deious.tistory.com/290
