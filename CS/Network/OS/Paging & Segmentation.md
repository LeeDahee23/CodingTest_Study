# 메모리 할당 방식

- what? 사용자가 사용하는 프로세스가 어떻게 메모리(유저 영역)에 할당되는지
1. **연속 메모리 할당**
    - 프로세스에 `연속적인` 메모리 공간을 할당하는 방식
    1. 고정 분할 방식 : 물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누어 두고 `각 분할에 하나의 프로세스를 적재`해 실행하는 방식
        - 외부 단편화 O, 내부 단편화 O
    2. 가변 분할 방식 : 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 `동적으로 변하는` 방식
        - 외부 단편화 O, 내부 단편화 X
        - 동적 메모리 할당 문제
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b65aa24f-f214-403a-bcbb-5542383f8c59/0bc5ce9a-29d5-49bd-804b-ab3b0e3215dc/Untitled.png)
  
            | 이름 | 설명 |
            | ------- | --- |
            | 최초 적합 | 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식 |
            | 최적 적합 | 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식 |
            | 최악 적합 | 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식 |
    
    - ⭐️ 외부 단편화 vs 내부 단편화
        - 단편화: 기억 장치의 `빈 공간` 또는 `여러 개의 조각`으로 나뉘는 현상
        
        - **외부 단편화**
            - `프로그램의 크기보다 분할의 크기가 작은 경우`에는 **해당 분할이 비어있는데도** 불구하고 프로그램을 **적재하지 못하는** 현상
                
                ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b65aa24f-f214-403a-bcbb-5542383f8c59/7988f999-7d55-4968-a69b-6601ec289161/Untitled.png)
                
        
        - **내부 단편화**
            - `프로그램의 크기보다 분할의 크기가 큰 경우` 해당 분할에 **프로그램을 적재하고 남는 현상**
            하나의 분할 내부에 사용되지 않는 메모리 조각이 생기는 현상
                
                ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b65aa24f-f214-403a-bcbb-5542383f8c59/2497f306-8897-4518-b183-5c4eb0aff745/Untitled.png)
                

1. **불연속 메모리 할당**
    - 프로세스에 `불연속적인` 메모리 공간을 할당하는 방식
    - 가상 메모리 관리
        - 물리메모리보다 큰 프로세스를 실행할 수 없음
        - 가상 메모리: 실행하고자 하는 `프로그램을 일부만 메모리에 적재`하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
    1. 페이징 : 단위가 고정크기
    2. 세그먼테이션 : 단위가 가변크기
    

## 페이징

- 메모리와 프로세스를 일정한 단위로 자르고, 이를 메모리에 `불연속적`으로 할당하는 방식
- 페이지: `프로세스`의 논리 주소 공간을 일정한 크기로 자른 단위
- 프레임: `메모리` 물리 주소 공간을 `페이지와 동일한 크기`로 자른 단위
    
    - 논리 주소 ? 물리 주소 ?
        - 물리 주소: 메모리 입장에서 바라본 주소, 정보가 실제로 저장된 하드웨어상의 주소
        - 논리 주소: CPU와 실행 중인 프로그램 입장에서 바라본 주소, 실행 중인 프로그램 각각에게 부여된 0번지부터 시작하는 주소

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b65aa24f-f214-403a-bcbb-5542383f8c59/bb2b7320-1c49-4a67-8394-f2642de023b7/Untitled.png)

- 페이지 테이블: 페이지 번호와 프레임 번호를 짝지어 주는 표
    - 프로세스가 물리 주소에 불연속적으로 배치되더라도 논리 주소(CPU가 바라보는 주소)에는 연속적으로 배치되도록 함
    - CPU가 페이지 테이블을 통해 페이지 번호만 보고, 해당 페이지가 어느 프레임에 적재되어 있는지 알 수 있음
    - 페이지 테이블의 시작주소를 page table base register에 저장함

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b65aa24f-f214-403a-bcbb-5542383f8c59/6b89dc8e-0687-45ca-8a09-705a1b4d1cec/Untitled.png)

- 외부 단편화 X
    - 페이지들의 크기가 프레임보다 큰 경우는 없기 때문
- 내부 단편화 O
    - 페이지 크기: 10, 프로세스의 크기: 26 → 마지막 페이지의 크기: 6
    - 마지막 페이지에는 4만큼의 크기가 남음!

## 세그먼테이션

- 프로세스를 `논리적 내용을 기반으로 나눠서` 메모리에 배치하는 방식
- 세그먼트: 코드, 데이터, 힙, 스택 영역 등과 같은 논리적 영역, 집합
    - 가변 크기
- 세그먼트 테이블: `세그먼트 번호`, `시작 주소`, `세그먼트 크기`를 가짐

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b65aa24f-f214-403a-bcbb-5542383f8c59/0a3b1741-0ae3-463c-b6d0-7285e7d758d6/Untitled.png)

- 외부 단편화 O
    - 메모리에 계속해서 세그먼트가 들어가고 나가고 반복하면, 각각의 상주되어 있는 세그먼트들 사이에는 작은 빈틈이 생길 수 있음 → 작은 빈틈보다 큰 세그먼트는 메모리에 들어갈 수 없음
- 내부 단편화 X
    - 세그먼트의 크기가 가변이기 때문

|  | 페이징 | 세그먼테이션 |
| --- | --- | --- |
| 크기 | 고정 | 가변 |
| 외부 단편화 | X | O |
| 내부 단편화 | O | X |
| 장점| 외부 단편화를 해결하기 때문에, 현재 대부분은 페이징 기법을 사용 | 보호와 공유에 효율적(세그먼트는 논리적 단위, 페이징은 고정 크기) |

## 참고

[https://ko.wikipedia.org/wiki/단편화](https://ko.wikipedia.org/wiki/%EB%8B%A8%ED%8E%B8%ED%99%94)

https://baebalja.tistory.com/416

[https://velog.io/@codemcd/운영체제OS-13.-페이징](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-13.-%ED%8E%98%EC%9D%B4%EC%A7%95)

[https://velog.io/@khs0415p/11-메모리의-주소-공간-물리주소와-논리주소](https://velog.io/@khs0415p/11-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84-%EB%AC%BC%EB%A6%AC%EC%A3%BC%EC%86%8C%EC%99%80-%EB%85%BC%EB%A6%AC%EC%A3%BC%EC%86%8C)

[보호와 공유 참고](https://dar0m.tistory.com/269)
