```
해결 ⭕️
bfs, 다익스트라 - 특정 도시에서 최단거리가 K인 도시 찾기 (도시 간 거리는 1)
다익스트라에서 우선순위큐를 쓰는 이유는 가중치!
```

# 문제
1번부터 N번까지의 도시와 길이가 1인 M개의 단방향 도로가 있다. X번 도시로부터 최단거리가 K인 도시들의 번호를 구하시오. <br/>
도시 번호를 오름차순으로 출력하고, 존재하지 않으면 -1을 출력<br/>
- 2 <= N <= 300,000
- 1 <= M <= 1,000,000
- 1 <= K <= 300,000

# 접근 방식
특정 도시에서 다른 도시까지의 최단 거리를 구하는 것이기 때문에 처음에는 다익스트라라고 생각했다.<br/>
그런데 도시간 거리가 모두 1이기 때문에 가중치를 계산하지 않아도 돼서 bfs로 풀었다.

# 풀이
1. 인접리스트 그래프
   - 도시의 개수가 최대 300,000까지 나올 수 있기 때문에 인접행렬로 구현하면 90,000,000,000개의 공간이 만들어져야 하기 때문에 메모리초과가 날 수 있다.
   - 그래서 인접리스트를 사용해서 그래프를 구현했다.
  
2. bfs, dist 배열
   - bfs로 똑같이 풀면 된다!
   - 사실 처음에는 도시의 모든 거리가 1인 다익스트라로 생각하고 풀었기 때문에 visited, dist 배열을 사용했다.
   - dist 배열을 모두 -1로 초기화하고 dist가 -1인 경우는 방문하지 않은 경우라고 걸러주면 visited 배열을 사용하지 않고도 구현이 가능하다.

#### bfs
```java
int[] dist = new int[N+1];
Arrays.fill(dist, -1);
Queue<Integer> q = new LinkedList<>();

dist[start] = 0;
q.add(start);

while(!q.isEmpty()) {
  int cur = q.poll();
  
  for(int next : graph.get(cur)) {
    if(dist[next] == -1) {
      dist[next] = dist[cur] + 1;
      q.offer(next);
    }
  }
}

return dist;
```

# 시행착오
1. 문제 풀기 전에 다익스트라 카테고리의 문제라서 & 최단경로 문제라서 다익스트라로 접근했다. 처음에는 무지성으로 우선순위큐를 사용해서 풀었는데 거리가 1이니까 가중치를 따로 두지 않았다. 
그랬더니 **우선순위큐가 노드번호를 정렬**했고 당연히 틀렸다! 그래서 우선순위큐를 큐로 바꿨더니 AC이었다.
2. 코드가 좋지 못한 것 같아서 (불필요한 배열 사용) bfs라고 생각하고 다시 풀었다.
