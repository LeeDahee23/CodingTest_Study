```
해결 ⭕️
DP 알고리즘 - BOJ 순서대로 점프를 할 때 필요한 에너지의 최솟값
반드시 B부터 시작하는데, 초깃값을 어떻게 설정해야 할지 헷갈림, Integer.MAX_VALUE 사용할 때 Integer 범위 벗어남
```

# 문제
1번부터 N번까지 보도블럭을 점프해서 가려고 하는데, B-O-J 순서대로 블럭을 밟아야 한다. k칸 점프할 때 필요한 에너지의 양이 k*k라고 할때, N번까지 가는데 필요한 에너지의 최솟값 구하기. 갈 수 없다면 -1 출력 <br />
(1 <= N <= 1000)

# 접근 방식
단순히 B칸 다음에 O칸, 다음에 J칸을 찾으면 최솟값을 얻을 수 없다. 이전 알파벳까지의 에너지 + (이전 알파벳과 현재 블럭까지의 거리)^2 을 구해서 최솟값을 찾아야 한다. <br />
그렇기 때문에 dp 알고리즘을 사용해서, 현재까지의 최소 에너지를 dp에 저장하고 그것을 이용해서 다음 블럭의 에너지를 구해야겠다고 생각했다.

# 풀이
블럭은 반드시 B-O-J 순서대로 밟아야 하기 때문에 'O' 전에는 'B', 'J' 전에는 'O', 'B' 전에는 'J' 이어야 한다.<br />
현재 블럭이 'B'라면, 이전에 있는 'J'들과의 에너지를 계산해서 그 중 최솟값이 현재 블럭까지의 에너지 양이 된다.<br />
마찬가지로 현재 블럭이 'O'라면 이전 'B'블럭과의 에너지, 현재 블럭이 'J'라면 이전 'O' 블럭과의 에너지를 구하면 된다.

코드로 쓰면 다음과 같이 쓸 수 있다.
```java
for(int i=1; i<input.length(); i++) {
  char now = input.charAt(i);
  
  for(int j=0; j<i; j++) {
    // 현재 'B'라면 이전의 'J' 블럭들과의 에너지 계산
    if(now == 'B' && input.charAt(j) == 'J') {
      dp[i] = Math.min(dp[i], dp[j] + (int)Math.pow(i-j, 2));
    }
    // 현재 'O'라면 이전의 'B' 블럭들과의 에너지 계산
    else if(now == 'O' && input.charAt(j) == 'B') {
      dp[i] = Math.min(dp[i], dp[j] + (int)Math.pow(i-j, 2));
    }
    // 현재 'J'라면 이전의 'O' 블럭들과의 에너지 계산
    else if(now == 'J' && input.charAt(j) == 'O') {
      dp[i] = Math.min(dp[i], dp[j] + (int)Math.pow(i-j, 2));
    }
  }
}
```


대신 첫번째 칸 'B'부터 무조건 시작해야 하기 때문에 초깃값을 잘 설정해줘야 한다!<br />
예를 들어 "BJBOJO" 에서는 4번째에 'O'가 있는데, 자신의 앞에 있는 'B'들과 계산한 값 중 최솟값을 구해야한다.<br />
1번째와 3번째에 'B'가 있는데 반드시 첫번째 칸부터 시작을 하기 때문에 첫번째 'B'에서 계산한 값을 초깃값으로 가져야 한다.<br />
그래서 첫번째 칸은 dp 값을 0이라고 설정하고 나머지 칸은 Integer.MAX_VALUE로 설정하여 최솟값을 구할 수 있게 했다.<br />

그렇게 하면 위 코드대로 돌렸을 때 최솟값을 잘 구할 수 있다.

하지만 "BJJOOOBB"와 같이 끝까지 도달할 수 없는 경우에는 Integer.MAX_VALUE이기 떄문에 계산하다보면 Integer의 범위를 벗어나서 -값이 나오게 되고, 최솟값이 잘못 구해지게 된다.
그래서 만약 자신의 이전 블럭이 dp 값이 이미 MAX라면 계산하지 않도록 조건을 넣어줘야 한다.
```
if(now == 'B' && input.charAt(j) == 'J' && dp[j] < Integer.MAX_VALUE) { ... }
```

마지막인 N-1번째 dp 값이 여전히 MAX_VALUE라면 도달할 수 없는 경우이고(-1 출력), 아니라면 그 값이 최소 에너지양이다.
