```
해결 ❓ - 이전 코드 참고
백트래킹 - 연산자 조합(만들 수 있는 식의 결과 중 최대, 최소 구하기)
```

# 문제
N개의 수와 N-1개의 연산자(+-*/)가 주어진다. 수의 순서를 바꾸지 않고, 연산자의 우선순위는 무시하고 앞에서부터 계산을 한다. 만들 수 있는 식의 결과의 최대값과 최소값을 구하시오.
- 2 ≤ N ≤ 11, 1 ≤ 수 ≤ 100

# 접근 방식
가지고 있는 연산자들로 만들 수 있는 `순열`을 모두 계산해봤을 때의 최댓값과 최솟값을 구하면 된다.<br/>
(가지고 있는 연산자들을 사용해서 나열하는 것이기 때문에 `순열`)<br/>
ex) + 2개, - 1개, * 1개, / 0개<br/>
➡️ ++-*, ++*-, +-+*, +-*+, +*-+, +*+-, -++*, -++*, … 

# 풀이
연산자 배열을 돌면서, 개수가 0보다 크다면 사용하고 0보다 작거나 같아지면 다음으로 넘어가는 방식으로 작성했다.<br/>
```java
private static void find(int[] nums, int[] op, int result, int depth) {
  if(depth == nums.length) {
    max = Math.max(max, result);
    min = Math.min(min, result);
    return;
  }
  
  for(int i=0; i<op.length; i++) {
    if(op[i] > 0) {
      op[i] --;
      find(nums, op, calculate(result, nums[depth], i), depth + 1);
      op[i] ++;
    }
  }
  
}
```

연산자를 사용하려면 op 배열 즉 개수를 하나 줄여준다.<br/>
재귀함수를 통해, 연산을 하고(calculate), depth를 하나 올려준다.<br/>
nums의 끝까지 연산이 끝나면 (depth == nums.length) max와 min을 갱신해주고 return 해서 함수를 호출했던 곳으로 돌아간다.<br/>

재귀함수가 모두 끝나면 연산자 개수를 다시 올려놓는다.<br/>

### 정리
백트래킹은 틀이 정해져 있는 것 같다.<br/>
종료조건 + 방문처리 + 재귀 호출 + 방문처리 취소<br/>
