```
해결 ⭕️
다익스트라 - 시작점에서 다른 노드까지의 최단 경로
📝 인접행렬이면 메모리초과, 시작노드 중복해서 시간초과
```

# 문제
방향그래프가 주어졌을 때 시작노드에서 다른 모든 노드까지의 최단 경로 구하기<br/>

- 1 <= 정점 개수 <= 20,000
- 1 <= 간선 개수 <= 300,000 

# 접근 방식
시작점에서 다른 노드까지의 최단 경로 -> **`다익스트라`**

# 풀이
다익스트라로 풀 때 필요한 것

- distance[] : 시작노드에서 다른 노드까지의 최단 거리를 저장하는 배열
- visited[] : 해당 노드 방문 확인 배열
- 우선순위큐 : 다음으로 탐색할 노드들 중 가중치가 작은 것부터 탐색할 수 있도록
- 그래프 : 간선들. 인접행렬과 인접리스트로 구현 가능

1. 그래프를 인접리스트로 구현
2. 초기 선언 & 초기화
   - 우선순위큐 선언(가중치를 기준으로 오름차순 정렬) 
   - distance를 INF로 초기화
3. 시작노드 초기화
   - distance 0으로 초기화
   - pq에 넣기 (시작노드, 0)
4. pq를 돌면서
   - 노드 하나 빼서 (현재 탐색해야할 노드들 중 가중치가 가장 작은 노드)
   - 방문처리 (이미 방문한 노드라면 continue)
   - 현재 노드에 연결되어 있는 노드들 확인. 현재 노드를 거쳐갈 때와 거치지 않았을 때의 가중치를 비교

<br/>

# 시행착오
1. 그래프 구현
   처음에는 그래프를 인접행렬로 구현해서 (V+1)*(V+1) 크기의 2차원 배열을 만들어서 풀었다.<br/>
   근데 메모리초과가 났다. 왜냐하면 정점이 최대 20,000개까지 나올 수 있는데 그러면 400,000,000 만큼의 공간이 필요하게 된다. int형이 4바이트 이니까 계산하면 1,600,000,000 바이트 = 1.6 기가바이트가 필요하게 된다.<br/>
   그래서 인접리스트로 구현을 했다.
   ```java
   ArrayList<ArrayList<Edge>> graph = new ArrayList<>();
   for(int i=0; i<=V; i++) {
			graph.add(new ArrayList<Edge>());
		}
   ```
   이렇게 공간을 만들어주고 값을 넣을 때에는 `graph.get(u).add(new Edge(v, w));` 처럼 해서 u에서 v까지의 가중치는 w 이라고 구현했다.

2. Edge 클래스
   원래는 배열로 해서 값을 {가중치, 노드번호} 이런 식으로 넣어줬는데 인덱스로 하려니까 뭐가 뭔지 헷갈렸다.
   그래서 Edge라는 클래스를 따로 만들어서 end까지의 가중치가 weight라는 식으로 작성했다.

3. 다익스트라 함수
   우선순위큐를 사용해서 다익스트라를 풀었는데, 처음에 시작노드에 대한 거리를 초기화해주고, 시작노드와 연결된 노드들에 대해서 따로 pq에 넣어주고 시작했다.<br/>
   그러려면 시작노드를 빼줘야 하는데, 안빼줘서 시작노드가 중복으로 처리가 됐고 시간초과가 났다.<br/>
   그래서 시작노드를 pq에 넣어주고 바로 pq를 돌면서 처리를 해줬다. 아직 다익스트라가 익숙하지 않아서 생긴 실수 같다!
