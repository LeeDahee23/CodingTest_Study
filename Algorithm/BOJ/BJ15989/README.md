```
해결 ⭕️
DP 알고리즘 - 1,2,3의 합으로 정수 n 만들기
😫 0부터 경우를 모두 그려봤는데 중복을 제거하는 방향으로 생각한 것이 문제
```

# 문제
정수 n을 1, 2, 3의 합으로 나타내는 방법의 수 구하기. 합을 이루고 있는 수의 순서만 다른 것은 같은 것으로 한다.

(0 < n <= 10,000)

# 접근 방법
1. n을 1, 2, 3의 합으로 나타내면, n-1에 1을 더했을 때, n-2에 2를 더했을 때, n-3에 3을 더했을 때 3가지 경우가 나오게 된다.<br/>
   그래서 dp 테이블에 i를 1,2,3의 합으로 만들 수 있는 방법의 수를 저장해 **dp[i-1], dp[i-2], dp[i-3]을 이용해서 dp[i]를 구할 수 있다**.(이전에 1,2,3 더하기 문제를 풀었어서 dp로 접근해야 한다는 것은 알고 있었다)
2. 이 문제에서는 순서만 다르면 같은 것으로 한다는 조건이 있어서 중복되는 것은 제외해야 한다. 시행착오를 거치고 나니, 중복을 제거해주는 것보다 **경우를 나누는게** 더 쉽겠다고 생각했다. <br />
   그래서 생각한 방법이 dp[i][1]: `1로만 i를 만들기`, dp[i][2]: `1~2로 i를 만들기(2 포함)`, dp[i][3]: `1~3으로만 i를 만들기(3 포함)` 이다.
   
   1. `1로만 i를 만들기` : 이 경우는 1가지 밖에 없다 (1+1+1+...+1)
   2. `1~2로 i를 만들기` : 이 경우는 2를 포함해야 하므로, i-2에 +2를 해서 i를 만드는 경우이다. 1~2로 만드는 것이기 때문에 dp[i-2][1] 과 dp[i-2][2]에 +2를 해주면 된다. dp[i-2][3]을 포함하면 3이 포함되기 때문에 제외해야 한다.
   3. `1~3으로 i를 만들기` : 이 경우는 3을 포함해야 하므로, i-3에 +3을 해서 i를 만드는 경우이다. 1,2,3 모두 사용할 수 있으니까 dp[i-3][1] dp[i-3][2] dp[i-3][3]에 +2를 해주면 된다.

  정리하면 점화식은 다음과 같이 된다.
   ```
   dp[i][1] = dp[i-1][1]
   dp[i][2] = dp[i-2][1] + dp[i-2][2]
   dp[i][3] = dp[i-3][1] + dp[i-3][2] + dp[i-3][3]
   ```
 |  | 0 | 1 | 2 | 3 | 4 | 5 |... | 
 |---|---|---|---|---|---|---|---|
 | dp[i][1] | 0 | 1 | 1+1 | 1+1+1 | 1+1+1+1 | 1+1+1+1+1 | ... |
 | dp[i][2] | 0 | 0 | 2 | 2+1 | 1+1+2, 2+2 | 1+1+1+2, 2+1+2 | ... |
 | dp[i][3] | 0 | 0 | 0 | 3 | 1+3 | 1+1+3, 2+3 | ... |

   - 시행착오 👽
     
     1부터 가능한 방법을 일단 나열했더니 i번째 수의 경우에는 (편의상 k번째 수의 방법을 make(k)라고 하겠다.)<br />
     1) make(i-1)는 모두 가져온다 (+ 1 하기)<br/>
     2) i-2번째의 경우는, make(i-2)에 + 2를 해야하는데 중복을 제거해야 한다. make(i-2)는 make(i-1)에 모두 포함되기 때문에, make(i-2)에서는 1이 포함되어 있는 경우를 빼줘야 한다고 생각했다 (make(i-1)는 1번에서 포함을 시켜놨기 때문)
        make(i-2)에서 1이 포함되어 있는 경우는 make(i-3)에서 +1을 해준 경우니까 i-2번째의 경우는 make(i-2) - make(i-3)을 한 값이 된다. <br />
        ~~내가 생각한 거지만 다시 읽어보면 뭐라는 건지..🤔~~
     3) i-3번째의 경우를 구해야하는데 중복 제거하는 걸 어떻게 해줘야 하는지 감이 잡히지 않아서 이 방법은 아니라고 생각했다.
      
# 풀이
점화식을 구했으니까 bottom-up으로 구현하면 쉽게 쓸 수 있다. <br/>
대신 dp로 풀 때 주의해야 할 점이 있는데 항상 이것 때문에 dp는 한번씩 틀리는 듯하다.

**🚨 dp 테이블에 초기값 넣을 때 조건문 필!** <br/>
바로 초기값을 지정할 때, 입력받는 값 n의 범위에 대한 조건문이 필요하다는 것이다. 말로 하면 복잡한데 코드를 보면 이해가 쉽다. <br/>
```java
int[][] dp = new int[n+1][4];
			
dp[1][1] = 1;
dp[1][2] = 0;
dp[1][3] = 0;

if(n >= 2) { // 🚨
  dp[2][1] = 1;
  dp[2][2] = 1;
  dp[2][3] = 0;
}

if(n >= 3) { // 🚨
  dp[3][1] = 1;
  dp[3][2] = 1;
  dp[3][3] = 1;
```

dp 테이블의 크기를 n+1이라고 지정해줬으니까 n의 값이 어떤 게 들어오는지에 따라 dp 테이블의 크기가 결정된다. <br />
만약 n이 0이라면 dp 테이블의 크기가 1이 되니까 dp[2][1~3]을 초기화 해주는 곳에서 ArrayIndexOutOfBounds 오류가 나게 된다!

그래서 dp 테이블의 초기값을 먼저 지정해줘야 한다면 n의 edge 값을 신경써야 한다.<br/>
아니면 dp 테이블의 크기를 n으로 지정하는 게 아니라 문제에서의 최대 값으로 지정해줘도 된다. n이 어떤 값이 들어오던지 상관없이 dp 테이블의 크기는 고정이기 때문! (이 문제에서는 최대 10,000이니까 dp[10001][4]로 선언)

### 정리
1. dp 테이블의 크기를 n의 최댓값으로 하드코딩 해주기
2. dp 테이블의 크기를 n이라고 했다면 (예. new int[n]), n의 edge 값에 따라 (대체로 n=0일 때) dp 테이블 초기값 지정 시 조건문 달아주기!
