```
해결⭕️, bfs
가야할 칸의 개수의 최솟값 => 최단거리
O(N^2)
```

# 문제

캐릭터를 동서남북 방향으로 한칸씩 이동해 (1,1)에서 (n,m)까지 가는데 걸리는 칸의 개수의 최솟값을 구하시오. 벽은 0, 길은 1이다. (n,m)에 갈 수 없다면 -1을 리턴하시오.

### 입출력

- 1 <= n, m <= 100

# 풀이

- 배열의 (0, 0)을 시작점으로 (n-1, m-1)까지 이동하는데 걸리는 최단거리를 구해야 함 => **bfs**
- maps에서 길이 1로 이뤄져 있으므로 거리를 maps에 구하기
- 방문처리도 maps의 값이 1보다 클 경우에는 방문했다고 침
  - (0, 0)은 처음부터 1이라서 방문을 했지만 방문하지 않은 것처럼 보일 수 있음 -> 최단거리를 구하기 때문에 답에는 영향x, 이전 칸의 값이 1보다 커서 괜찮음
- bfs
  - 시작점을 큐에 넣고 방문 처리
  - 큐가 빌 때까지 반복
    - 큐에서 하나 꺼냄 (현재 노드)
    - 현재 노드가 도착 지점인지 확인
      - 도착 지점이라면 종료
    - 현재 노드에서 이동할 수 있는 칸의 위치를 큐에 넣고 방문처리, 거리 더하기

# 시간복잡도

- 주어진 그래프가 인접행렬: O(N^2)
